# `coreg`: Image co-registration module

`coreg` computes an affine transformation from a subject's image to the same subject's high-resolution anatomical scan (for instance, a T1-weighted MPRAGE). `coreg` only computes the transformation and does not apply it; all transformations are applied in a single step by the `norm` module in order to reduce computational requirements and minimise the number of interpolation steps.

## Module configuration

### `coreg_reference`

_Image to align._

Co-registration aligns a representative image from the source sequence to a high-resolution reference from the same subject. When the source sequence has multiple images (e.g., frames of a BOLD time series or directions of a DWI sequence), one of these images may be selected to represent the source sequence. Alternatively, the average of all images in the source sequence can be used as the reference for co-registration. `coreg_reference` specifies whether to use a single representative image from the input sequence or the average of all sequence images as the reference for co-registration. In some cases, using the average image (the derivative `meanIntensity` in the pipeline) improve tissue contrast or decrease noise. In other cases, a single image with carefully selected acquisition parameters (the derivative `referenceVolume` in the pipeline) might produce improved results.

```bash
# Co-register a single reference image
coreg_reference[cxt]=exemplar

# Co-register the average of all images
coreg_reference[cxt]=mean
```

The image selected as the reference for co-registration will become the map of the sequence's native space in the spatial metadata used by the pipeline.

### `coreg_cfunc`

_Cost function to be optimised._

The alignment of the input image to the target is performed in such a manner as to optimise the value of the cost function specified by `coreg_cfunc`. Any of the cost functions that are available in FSL's `flirt` can be used.

```bash
# Use boundary-based registration (recommended, requires segmentation with white matter)
coreg_cfunc[cxt]=bbr
coreg_seg[cxt]=/path/to/segmentation.nii.gz
coreg_wm[cxt]=3

# Use correlation ratio
coreg_cfunc[cxt]=corratio

# Use normalised mutual information
coreg_cfunc[cxt]=normmi
```

### `coreg_seg` and `coreg_wm`

_White matter segmentation for boundary-based registration._

If you are using a cost function other than `bbr` for coregistration, then the values of `coreg_seg` and `coreg_wm` will not be used.

Boundary-based registration (Greve and Fischl, 2009) uses the intensity differences between grey and white matter (present in EP images) to align convolutions in the white-matter surface of the anatomical reference image to analogous convolutions in the white-matter surface of the input image. This approach requires a known segmentation of the anatomical image into tissue classes. If you provided an output directory from the ANTsCT routine or the anatomical stream, then a segmentation will automatically be available as the derivative `segmentation`.

```bash
# Use a custom segmentation
coreg_seg[cxt]=/path/to/segmentation.nii.gz

# Use the segmentation generated by the subject's anatomical stream or ANTsCT pipeline
coreg_seg[cxt]=${segmentation[sub]}
```

In some segmentations, such as the one output by ANTs Cortical Thickness, each tissue class is assigned a different intensity value in the segmentation volume. For instance, 1 might correspond to CSF, 2 to cortical grey matter, 3 to white matter, etc. If your segmentation is strictly a binary-valued white matter mask, then enter `ALL`. To enter a range of values, use the colon (`:`) delimiter; to enter multiple values, use the comma (`,`) delimiter.

```bash
# 3=WM in coreg_seg
coreg_wm[cxt]=3

# All nonzero values are WM in coreg_seg
coreg_wm[cxt]=ALL

# All values in the closed interval [5,9] as well as 9 are WM in coreg_seg
coreg_wm[cxt]=1:5,9
```

### `coreg_denoise`

Not currently used.

### `coreg_refwt` and `coreg_inwt`

_Voxelwise weights for coregistration._

A volume containing cost function weights can be used to set the relative importance of different voxels or brain regions in computing an optimal coregistration. For instance, weighting voxels in the ventricular region highly could promote a coregistration solution that optimises alignment of the ventricular boundaries of input and reference volumes. You may use weights in the input/sequence/analyte space (`coreg_inwt`), weights in the reference/anatomical space (`coreg_refwt`), or both if you elect to use weights.

```bash
# Weights for sequence/analyte image
coreg_inwt[cxt]=/path/to/weights/in/sequence/space.nii.gz

# Weights for anatomical image
coreg_refwt[cxt]=/path/to/weights/in/anatomical/space.nii.gz
```

### `coreg_qacut` and `coreg_decide`

_Assessment of coregistration quality._

`coreg_qacut` determines cutoffs for variables that measure coregistration quality; this should be a comma-separated list of 4 values. Negative or nonsense values indicate that the quality metric should not be taken under consideration. If coregistration fails to meet the quality cutoff, then it will automatically be repeated using another cost function (`corratio` unless `coreg_cfunc[cxt]=corratio`, in which case this will be `mutualinfo`).

```bash
# Flag coregistration if either
# (i)   cross-correlation is less than 0.7 or
# (ii)  coverage is less than 80 percent
coreg_qacut[cxt]=0.7,0.8,-1,-1

# Flag coregistration if either
# (i)   cross-correlation is less than 0.7 or
# (ii)  coverage is less than 80 percent or
# (iii) Jaccard coefficient is less than 0.5 or
# (iv)  Dice coefficient is less than 0.6
coreg_qacut[cxt]=0.7,0.8,0.5,0.6

# Skip quality control (report metrics but never retry coregistration)
coreg_qacut[cxt]=-1,-1,-1,-1
```

Coregistration quality is estimated using the utility `maskOverlap`, which computes metrics of similarity between the anatomical brain mask and the analyte brain mask after it has been aligned to anatomical space. The quality control metrics are as follows:

 * _Spatial cross-correlation_
 * _Coverage_ (fraction of the smaller of the two masks -- typically the anatomical mask -- covered by the larger of the two masks)
 * _Jaccard coefficient_
 * _Dice coefficient_

The input should be formatted:

`crosscorr,coverage,dice,jaccard`

In the event that (after failing quality assessment) coregistration is repeated, `coreg_decide` specifies which of the four quality metrics should be used to decide whether to keep the original coregistration or the repeated coregistration. (The registration that performs better according to the specified metric will be retained.)

```bash
# Use cross-correlation to decide which coregistration to keep
coreg_decide[cxt]=0

# Use coverage to decide which coregistration to keep
coreg_decide[cxt]=1

# Use Jaccard coefficient to decide which coregistration to keep
coreg_decide[cxt]=2

# Use Dice coefficient to decide which coregistration to keep
coreg_decide[cxt]=3
```

### `coreg_mask`

_Use the coregistration for brain extraction._

If a high-quality coregistration between sequence space and anatomical space can be obtained consistently, then the quality of brain extraction could potentially be improved by aligning the anatomical brain mask into sequence space and then using it to estimate the boundaries of the sequence brain. This will typically result in a mask that conforms tightly and precisely to the brain boundary. However, even a slight registration error using such a precise mask can result in loss of brain tissue.

```bash
# Use the aligned anatomical image for brain extraction
coreg_mask[cxt]=1

# Keep the sequence-only brain extraction (default)
coreg_mask[cxt]=0
```

### `coreg_rerun`

Ordinarily, each module will detect whether a particular analysis has run to completion before beginning it. If re-running is disabled, then the module will immediately skip to the next stage of analysis. Otherwise, any completed analyses will be repeated.If you change the run parameters, you should rerun any modules downstream of the change.

```bash
# Skip processing steps if the pipeline detects the expected output
coreg_rerun[cxt]=0

# Repeat all processing steps
coreg_rerun[cxt]=1
```

### `coreg_cleanup`

Modules often produce numerous intermediate temporary files and images during the course of an analysis. In many cases, these temporary files are undesirable and unnecessarily consume disk space. If cleanup is enabled, any files stamped as temporary will be deleted when a module successfully runs to completion. If a module fails to detect the output that it expects, then temporary files will be retained to facilitate error diagnosis.

```bash
# Remove temporary files
coreg_cleanup[cxt]=1

# Retain temporary files
coreg_cleanup[cxt]=0
```
